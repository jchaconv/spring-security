
Course: 
Spring Security Zero to Master along with JWT,OAUTH2

start: 28/11/2025


my repo: https://github.com/jchaconv/spring-security

course repo: https://github.com/eazybytes/spring-security


***************************
Section 1: Getting Started
***************************

- Create a spring boot project
    - java17, maven
    - spring boot 4.0.0
    - group: com.vilelo
    - artifact: springsec-section1
    - description: Demo project for Spring Boot and Spring Security
    - Dependencies: web, devtools

- Create a simple controller, run the app and go to http://localhost:8080/welcome
    - the log pattern format is interesting

- Secure the app:

    - add the spring-security dependency
    - rerun and there is no access to /welcome, it will show a login
    - user, and the password is in the console log
    - if i refresh the tab, the app is not asking the credentials again and again

    - i can add user.name and password in properties

- What is Security & Why it is important?

    - Similar to banks, our apps hold valuable data. Is necessary to secure the app in
      order to protect the data and business logic.

    -  Is a non functional requirement because no client ask for security in their app.
       Security is important as scalability, performance and availability.

    - Implement security from development phase. The more earlier you implement security in your app
      the better app you build.

    - Security Is important because if we lose data, the business loss money.

    - Spring security helps to avoid common attacks.

    - Responsability of the dev: the security of the web app layer.
        - Authentication
        - Authorization
        - Protection from exploits like CSRF, CORS, etc.


- Servlets & Filters

    - Everything in java web apps are driven by Servlets.
      The Servlet Container (Web Server, Tomcat the most used) converts the HTTP messages into ServletRequest(Java object),
      and deliver it to the Servlet method as a parameter. Also, receives the output of the
      ServletResponse.

      With spring framework we are just worry about coding the business logic and not of the servlet configurations.

    - Filters: intercept each request/response and do some pre work before business logic.

- Internal architecture of Spring Security  (* indicates that is a single component)

    - User entered credentials
    * Spring Security Filters, to identify if the user is authenticated
    * Authentication, is an object(username, passwrord, isAuth=false) that represents the credentials
    * Authentication Manager, take the request and deliver it to the next component
    * Authentication Providers, using it's components, this do the autentication(comparison)
        * UserDetailsManager/Service
        * Password Encoder

    * Security Context, if the auth is correct, the filter stores the session in this component
    - finally, filter sends a response.

- Demo of Spring Security internal flow (don't do it)

    - Logging trace in .properties
    - settings -> maven -> importing -> Automatically download (3 checks)
        - also, in the maven option(right hand), there are options to download source and docs
        - put a breakpoint inside doFilter method
        - do some navigation through lib classes.

    - JSESSIONID is the cookie that spring security save in the context and use it to validate the authentication.



********************************************************
Section 2: Changing the default security configurations
********************************************************

Services without security:
    - /contact
    - /notices

Services with security:
    - /myAccount
    - /myBalance
    - /myLoans
    - /myCards

    - Create project springsec-section2
    - Configuration class
    - don't use .permiteAll() 
    - after denyAll() we receive a 403
    - disable formLogin and httpBasic authentication


**********************************************************************
Section 3: Defining & Managing Users using InMemoryUserDetailsManager
**********************************************************************

branch: feature/section3-managing-users-in-memory

    - I used the pre-request option in postman, so I just need to put /myAccount
      to test the API, and provide the specified credentials in this exercise.

    Configuring users using InMemoryUserDetailsManager

        - delete username and password from properties
        - edit ProjectSecurityConfig
        - create UserDetailsService bean
        - use the InMemoryUserDetailsManager class
        - {noop}  --> indicates there is no password encoder
        - test with /myAccount

commit: f66b947815a23

--------------------------------------

    Configuring PasswordEncoder using PasswordEncoderFactories

        - To avoid the hardcoded password
        - BCrypt encoder by default
        - https://bcrypt-generator.com/
            - password: 5678  for the admin


commit: 969235f6897bb

--------------------------------------

    CompromisedPasswordChecker: To ask for a robust password

        - add bean CompromisedPasswordChecker on ProjectSecurityConfig
        - passwords are the same for user and admin Admin@3s12
        - not working for version changes.

        @Bean
        public CompromisedPasswordChecker compromisedPasswordChecker() {
            return new HaveIBeenPwnedRestApiPasswordChecker();
        }

        - finally I don't add this fragment.

--------------------------------------


******************************************************
Section 4: Defining & Managing Users using a Database
******************************************************

branch: feature/section4-managing-users-in-database


    - Creating MySQL Databse using Docker

        - using the Ubuntu distribution on windows 11
        - sudo apt install docker.io
        - sudo usermod -aG docker $USER    ---> adding my user to the docker group
        - newgrp docker  ----> this temporarily updates your current shell's group memberships without requiring a full logout.
        
        - in case of certficate error:

            - openssl s_client -connect registry-1.docker.io:443 -showcerts
            - sudo nano /usr/local/share/ca-certificates/proxy1.crt   ---> ctrl + o then ctrl + x
            - sudo nano /usr/local/share/ca-certificates/proxy2.crt
            - sudo nano /usr/local/share/ca-certificates/proxy3.crt
            - sudo update-ca-certificates
            - sudo service docker stop
            - sudo service docker start

        - docker pull mysql:latest
        - docker run -p 3306:3306 --name springsecurity -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=eazybank -d mysql

        - https://sqlectron.github.io/
            - name: springsecurity
            - localhost:3306
            - root:root



--------------------------------------

    - Understanding JdbcUserDetailsManager & creating Users inside the DB

        - use the querys from users.ddl without "ignorecase" (spring-security)
        - i saved this query on sql/script.sql

            create table users(username varchar(50) not null primary key,password varchar(500) not null,enabled boolean not null);
            create table authorities (username varchar(50) not null,authority varchar(50) not null,constraint fk_authorities_users foreign key(username) references users(username));
            create unique index ix_auth_username on authorities (username,authority);

        - execute the query inside the script file.


--------------------------------------


    - Using JdbcUserDetailsManager to perform authentication

        - add Dependencies to the project: jdbc, mysql and jpa
        - add connection properties
        - edit UserDetailsService adding  JdbcUserDetailsManager on ProjectSecurityConfig
        - user:EazyBytes@12345
        - successful test


--------------------------------------

    - Creating our own custom tables for Authentication
        - create table customer and insert rows
    
    - Creating JPA Entity and repository classes for new table
        - create model/Customer and use lombok
        - create CustomerRepository
        - add annotations on the main class. currently commented
    
    - Creating our own custom implementation of UserDetailsService
        - create config/EazyBankUserDetailsService
        - edit ProjectSecurityConfig, comment the jdbc manager.




--------------------------------------


    - Building a new REST API to allow the registration of new User

        - create controller/UserController
        - make public the endpoint in ProjectSecurityConfig
        - for transactions methods the framework enforces CSRF protection
            - edit the ProjectSecurityConfig
        - the test was successful with /register endpoint and no auth.



--------------------------------------


******************************************************
Section 5: Password Management with PasswordEncoders
******************************************************

branch: feature/section5-password-mngmnt-with-encoders

encode: no secure, just convert data from one form to another. Not the right option for password management.

    - prepare a plain.txt file with this value Jchacon@4432
    - openssl base64 -in plain.txt -out encode.txt
    - openssl base64 -d -in encode.txt -out decode.txt


encryption: Not the right option for password management.
    - transform data in such a way that guarantees confidentiality.
    - plain text -> encrypted text (cipher text) -> plain text  | encrypt and decrypt processes. 
    - suitable for encrpyt data in rest and at rest(ex: s3 bucket aws)
    - uses a key. guarantees confidentiality. encryption reversible by using the key.
        - symmetric: only one key for encrypt and decrypt
        - asymmetric: public key for encrypt and private key for decrypt. ideal for data in transit.

    - openssl enc -aes-256-cbc -pass pass:12345 -pbkdf2 -in plaint.txt -out encrpyt.txt -base64
    - openssl enc -aes-256-cbc -base64 -pass:12345 -d -pbkdf2 -in encrpyt.txt -out decrypt.txt


hashing: securily way to store passwords in database

    - input any kind of data and produce a unique string of bytes(Digest or Hash)
    - irreversibility, not possible to deduce the input, not possible to reverse the process to know the
      original input. Only 1 way.
    - the output hash value is always the same for a specific input.
    - typical approach to storing passwords, just store de hash value and compare them at the moment of login
    
    - PasswordEncoder interface and its popular implementations such as BCryptPasswordEncoder
    - DelegatingPasswordEncoder to delegates to the correct impl based on the prefix of the password. ex: {bcrypt}12345
    
    Drawbacks of hashing:
        - Brute force attack: calculate the hash value trying different plain text values. ex: calculate pin.
        - Dictionary or Rainbow attach: table with all possible combinations. millions of hash records.
        - Super fast: even for hackers, milliseconds.

    How to overcome Drawbacks:

        - limit the failed attempts
        - enforce the complexity of plaint text password
        
        - Salts during password hashing
            - password given by the client: 1234
            - salt value(random value): xyzm
            - total value given to the hash function: xyzm1234 ----> hash value: qwerty
            - saved value on database: salt + hash value ---> xyzmqwerty
            - when the login take place, the framework get the salt value with the plain text password and perform the hash function.
            - if the value matches with the stored in database, then the login is successful, otherwise it will be rejected.

        - use password hashing algorithms(bcrypt, scrypt, argo2 etc) to delay the process of hashing. It requires lots of cpu time and ram memory.
          the hacked may spend years to discover a robust password.

    Tests:

    - echo -n "Juliochaconv@12345" | openssl dgst -sha256     --> execute multiple times and the output is always the same
    
    - openssl dgst -sha256 jdk.*****.dmg     ---> to compare the hash value with the provide of oracle in the download link (sha-256)

    In the project I use the bcrypt algorithm with the passwordencoderdelegation in ProjectSecurityConfig class.


--------------------------------------

*********************************************************************
Section 6: Understanding Authentication Provider and Implementing it
*********************************************************************

branch: feature/section6-understanding-authentication-provider

- The ProviderManager identifies which is the appropiate Provider to authenticate a certain request
- we need to provide our own AuthenticationProvider
    - I think if there is an specific authentication requirements

- Check the interfaces and implementations:
    - Authentication
        - TestingAuthenticationProvider
    - AuthenticationProvider
    - ProviderManager (is a class)


---------------------------------

Implementing and Customizing the AuthenticationProvider inside our application

- tip: settings -> editor -> file types -> ignored files and folders
    - press + and after write press enter
        - .mvn
        - .idea
        - .gitignore
        - .gitattributes

- Create config.EazyBankUserPwdAuthenticationProvider
    - copy logic from AbstractUserDetailsAuthenticationProvider
    - in authenticate method is possible to add the specific authentication logic requirements

- run docker container and then start the app 

- To connect to MySQL from DBeaver, it is necessary to change this parameters in "Driver properties" option:
    - allowPublicKeyRetrieval=true
    - useSSL=false

- Test in debug mode
    - breakpoints in support and authenticate methods
    - invoke /myAccount  julio_chacon@epamneoris.com | ep4m55667
    - uncheck the "hide frames from libraries" option in debug mode
    - The default DaoAuthenticationProvider is relegated because of our own AuthenticationProvider
    - the success method is executed first and then the authenticate method
    - test successful










